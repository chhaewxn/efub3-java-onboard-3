# 자바 핵심 개념 정리 3
<details>
<summary>POJO란 무엇일까요?</summary>
<div markdown="1">

POJO란 `Plain Old Java Object`의 약자로, 자바에서 일반적인 객체이며 특정한 자바 기술이나 프레임워크에 의존하지 않고 순수하게 자바 언어만으로 구현된 객체이다.

POJO는 주로 데이터를 저장하고 처리하기 위한 목적으로 사용되며 이 객체는 기본적으로 멤버 변수와 getter/setter 메서드로 이루어져 있고 일반적으로 비즈니스 로직을 포함하지 않는다. 이러한 POJO 객체는 자바에서 데이터 전달을 위한 일반적인 방법으로 사용되며, 예를 들어 데이터베이스나 파일에서 데이터를 읽어들이거나 웹 애플리케이션에서 사용자 입력 데이터를 처리하는 데 사용될 수 있다.

POJO를 사용하면 코드의 가독성과 유지보수성을 향상시키는 데 도움이 되며, 자바 개발자들은 이를 통해 더 효율적이고 생산적인 개발을 할 수 있다.
</div>
</details>
<br>

<details>
<summary>제너릭이 무엇인가요? 컬렉션 클래스에서 제너릭을 사용하는 이유를 설명해 주세요.</summary>
<div markdown="1">

자바에서 제너릭은 클래스 또는 인터페이스를 정의할 때 타입 매개변수를 사용하여, 다양한 타입의 객체를 다룰 수 있는 클래스나 메서드를 작성할 수 있도록 해주는 개념

#### 컬렉션 클래스에서 제너릭을 사용하는 이유

- 타입 안전성 보장: 제너릭을 사용하면 컬렉션 클래스가 저장하는 데이터의 타입을 사전에 명시할 수 있다. 이를 통해 잘못된 타입의 데이터가 저장되는 것을 방지하고, 타입 불일치로 인한 런타임 오류를 사전에 방지할 수 있다.

- 코드 가독성 향상: 제너릭을 사용하면 코드의 가독성이 향상된다. 타입 명시를 통해 코드의 의도를 명확하게 전달할 수 있으며, 타입 캐스팅 코드를 줄일 수 있다.

- 유연성: 제너릭을 사용하면 컬렉션 클래스를 다양한 타입의 데이터를 저장할 수 있도록 만들 수 있다. 이를 통해 컬렉션 클래스를 재사용하기 쉬워지며, 코드 중복을 줄일 수 있다.
</div>
</details>
<br>

<details>
<summary>자바의 클래스 멤버 변수 초기화 순서에 대해 알려주세요.</summary>
<div markdown="1">

1) 클래스 변수(static 변수) 초기화: 클래스 변수는 클래스가 로딩될 때 한 번 초기화된다. 초기화는 변수 선언시 할당된 값 또는 static 블록에서 지정된 초기화 값으로 이루어진다. 만약 초기화 값이 없다면, 해당 변수는 기본값으로 초기화된다.

2) 인스턴스 변수 초기화: 객체가 생성될 때 인스턴스 변수는 초기화된다. 초기화는 변수 선언시 할당된 값 또는 인스턴스 초기화 블록에서 지정된 초기화 값으로 이루어진다. 만약 초기화 값이 없다면, 해당 변수는 기본값으로 초기화된다.

3) 생성자 호출: 객체가 생성될 때 생성자가 호출된다. 생성자에서 인스턴스 변수의 초기화 작업이 이루어질 수 있다.

➕ 초기화 블록을 사용하여 클래스나 인스턴스 변수를 초기화할 수도 있다. 클래스 초기화 블록은 static 블록으로 선언하며, 클래스 변수를 초기화하는데 사용된다. 인스턴스 초기화 블록은 인스턴스 변수를 초기화하는데 사용된다. 인스턴스 초기화 블록은 클래스 내부에 선언된 중괄호({})로 둘러싸인 블록으로, 객체가 생성될 때마다 실행된다. 초기화 블록은 생성자 호출 이전에 실행된다.
</div>
</details>
<br>

<details>
<summary>직렬화란 무엇인가요?</summary>
<div markdown="1">

자바에서 직렬화란, 객체를 바이트(byte) 스트림으로 변환하는 과정을 말한다. 변환된 바이트 스트림을 이용하여 객체를 파일에 저장하거나, 네트워크를 통해 전송할 수 있다.

직렬화를 사용하면, 객체를 전송하거나 저장할 때 편리하게 사용할 수 있다. 예를 들어, 네트워크를 통해 객체를 전송할 때는 객체를 직렬화한 후, 바이트 스트림으로 전송하고, 받은 쪽에서는 바이트 스트림을 역직렬화하여 객체로 복원할 수 있다. 또한, 객체를 파일에 저장할 때도 직렬화를 사용하여 객체를 파일에 쉽게 저장할 수 있다.
</div>
</details>
<br>

<details>
<summary>[예습] SOLID에 대해 알아봅시다.</summary>
<div markdown="1">

SOLID는 객체 지향 설계의 다섯 가지 원칙. SOLID 원칙은 소프트웨어 시스템을 설계할 때, 유지보수성, 확장성, 재사용성, 이해성 등을 높이기 위해 고려해야 하는 원칙이다.

S : 단일 책임 원칙(Single Responsibility Principle)
객체는 단 하나의 책임만을 가져야 한다. 객체가 수행하는 작업이 하나이기 때문에 변경 사항이 발생하더라도 다른 책임에 영향을 미치지 않아 유지보수가 용이해진다.

O : 개방-폐쇄 원칙(Open-Closed Principle)
객체는 확장에는 열려 있으나 변경에는 닫혀 있어야 한다. 즉, 기존의 코드를 변경하지 않고도 기능을 추가할 수 있도록 설계되어야 한다.

L : 리스코프 치환 원칙(Liskov Substitution Principle)
자식 클래스는 언제나 부모 클래스를 대체할 수 있어야 한다. 즉, 자식 클래스에서는 부모 클래스에서 정의한 메서드를 모두 사용할 수 있어야 한다.

I : 인터페이스 분리 원칙(Interface Segregation Principle)
클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다. 인터페이스를 작은 단위로 분리함으로써, 클라이언트는 필요한 메서드만 사용할 수 있으며, 불필요한 메서드에 의존하지 않아 유지보수가 쉬워진다.

D : 의존 역전 원칙(Dependency Inversion Principle)
추상화에 의존해야 하며, 구체화에 의존하면 안 된다. 즉, 인터페이스나 추상 클래스와 같은 추상화된 것에 의존하여, 구체적인 구현체에 의존하지 않아야 한다. 이를 통해 유연하고 확장성 있는 시스템을 만들 수 있다.
</div>
</details>
<br>

<details>
<summary>[예습] DI는 무엇일까요?</summary>
<div markdown="1">

DI는 객체가 필요로 하는 의존성을 외부에서 주입해주는 것을 말한다. 보통 객체 간의 의존성을 강하게 결합하면, 하나의 객체를 변경할 때 다른 객체도 변경해야 하는 문제가 발생할 수 있다. DI는 이러한 문제를 해결하기 위해 객체 간의 결합도를 낮추는 방식으로 작동한다.

DI는 대표적으로 생성자 주입(Constructor Injection), setter 주입(Setter Injection), 필드 주입(Field Injection) 방식이 있다.

- 생성자 주입(Constructor Injection)
  객체를 생성할 때 생성자 파라미터를 통해 의존성을 주입하는 방식

- Setter 주입(Setter Injection)
  Setter 메서드를 통해 의존성을 주입하는 방식

- 필드 주입(Field Injection)
  필드 선언부에 @Autowired 어노테이션을 사용하여 의존성을 주입하는 방식

DI를 사용하면, 의존성을 관리하는 부분을 외부에서 담당하게 되므로 객체 간의 결합도가 낮아져 유지보수성과 확장성이 높아진다. 또한, 의존성이 외부에서 주입되므로 코드 재사용성도 높아진다. 따라서 DI는 소프트웨어의 품질을 향상시키는 중요한 개념 중 하나이다.
</div>
</details>
<br>